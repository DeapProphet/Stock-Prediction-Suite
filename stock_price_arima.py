# -*- coding: utf-8 -*-
"""Stock Price ARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xZHWi0Z6xcs6Qzky4ZnAVlhJAXr-o4GS
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pmdarima as pm
import io
from google.colab import files
from sklearn.metrics import mean_squared_error

# ---------------------------------------------------------
# 1. UPLOAD
# ---------------------------------------------------------
print("Upload your 6 bank files...")
uploaded = files.upload()
filenames = list(uploaded.keys())

if not filenames:
    raise ValueError("No files uploaded.")

# ---------------------------------------------------------
# 2. SETUP PLOTS
# ---------------------------------------------------------
rows = len(filenames)
fig, axes = plt.subplots(rows, 1, figsize=(12, 6 * rows))
if rows == 1: axes = [axes]

print(f"\nOptimization Mode: Log-Transformed Rolling Forecast.")
print(f"Processing {rows} datasets...")

# ---------------------------------------------------------
# 3. OPTIMIZED LOOP
# ---------------------------------------------------------
for i, filename in enumerate(filenames):
    print(f"\nAnalyzing {filename}...")

    # --- A. LOAD ---
    try:
        df = pd.read_csv(io.BytesIO(uploaded[filename]))
    except:
        continue

    # Note: Using your specific column name with the space
    possible_cols = ['Adj Close ', 'Adj_Close', 'Close', 'Price']
    target_col = next((c for c in possible_cols if c in df.columns), None)

    if not target_col:
        print(f"Skipping {filename}: Target column not found.")
        continue

    df = df.dropna(subset=[target_col])
    values = df[target_col].values

    # --- B. LOG TRANSFORM ---
    # Squashes high variance (volatility) to make it easier for ARIMA
    # We add 1e-6 just in case of zero values, though unlikely in stocks
    log_values = np.log(values)

    # Split
    n_total = len(log_values)
    split_idx = int(n_total * 0.8)

    # Train/Test on LOG scale
    train_log = log_values[:split_idx]
    test_log = log_values[split_idx:]

    print(f"   Training initial model on {len(train_log)} samples...")

    # --- C. AUTO-ARIMA (Initial Fit) ---
    # We fit ONCE on the training set
    model = pm.auto_arima(train_log,
                          start_p=1, start_q=1,
                          max_p=5, max_q=5, # Increased complexity allowed
                          d=None,           # Let it find differencing
                          seasonal=False,
                          stepwise=True,
                          suppress_warnings=True,
                          error_action='ignore')

    print(f"   âœ… Best Order: {model.order}. Starting Rolling Forecast...")

    # --- D. ROLLING FORECAST (The Optimization) ---
    # We predict t+1, then update the model with actual t+1, then predict t+2...
    preds_log = []

    # We iterate through the test set one by one
    for new_ob in test_log:
        # 1. Predict next step
        fc, conf = model.predict(n_periods=1, return_conf_int=True)
        preds_log.append(fc[0])

        # 2. Update the model with the REAL observation from test set
        # This keeps the model "fresh" without full retraining
        model.update(new_ob)

    # --- E. INVERSE TRANSFORM ---
    # Convert Log-Price back to Dollar-Price
    preds_price = np.exp(preds_log)
    actual_price = np.exp(test_log)
    train_price = np.exp(train_log)

    # Calculate RMSE
    rmse = np.sqrt(mean_squared_error(actual_price, preds_price))
    print(f"   ðŸ“‰ Final Test RMSE: {rmse:.4f}")

    # --- F. PLOTTING ---
    ax = axes[i]

    # Axes setup
    x_train = np.arange(0, split_idx)
    x_test = np.arange(split_idx, n_total)

    ax.plot(x_train, train_price, color='gray', alpha=0.4, label='History')
    ax.plot(x_test, actual_price, color='blue', linewidth=1.5, label='Actual')

    # The forecast should now hug the actual line much tighter
    ax.plot(x_test, preds_price, color='red', linewidth=1, linestyle='--', label='Rolling Forecast')

    ax.set_title(f"{filename} | Rolling ARIMA {model.order} | RMSE: {rmse:.2f}")
    ax.legend(loc='upper left')
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
